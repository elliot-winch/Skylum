// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel World

#include "Packages/jp.keijiro.noiseshader/Shader/ClassicNoise3D.hlsl"

#include "Field.compute"

struct Island
{
	float4 center;
	float size;
};

//Noise incuded here as it didn't work in a separate file
struct NoiseParameters 
{
    int octaves;
    float startingFrequency;
    float frequencyStep;
    float startingAmplitude;
    float amplitudeStep;
    float4 noiseOffset;
};

struct CosineWave 
{
    float Frequency;
    float Amplitude;
    float Phase;
    float DC;
};

RWStructuredBuffer<NoiseParameters> noiseParameters;
uint numIslands;
RWStructuredBuffer<Island> islands;
uint numWaves;
RWStructuredBuffer<CosineWave> waves;

float addNoise(float3 pos, NoiseParameters parameters)
{
    float noise = 0;
    float frequency = parameters.startingFrequency;
    float amplitude = parameters.startingAmplitude;

    for (int j = 0; j < parameters.octaves; j++) 
    {
        float3 noisePos = pos + parameters.noiseOffset.xyz;
        float normalisedNoises = ClassicNoise(pos * frequency);
        noise += normalisedNoises * amplitude;
        amplitude *= parameters.amplitudeStep;
        frequency *= parameters.frequencyStep;
    }

    return noise;
}

static const float PI = 3.14159265f;

float calculateIslandSize(float angle)
{
    float size = 0;
    for(uint i = 0; i < numWaves; i++)
    {
        size += cos(angle * waves[i].Frequency + waves[i].Phase) * waves[i].Amplitude + waves[i].DC; 
    }

    return size;
}

float islandValue(float3 pos)
{
	float maxIslandValue = -100;
	for(uint i = 0; i < numIslands; i++)
	{
        float3 center = islands[i].center.xyz;
        float3 relativePos = pos - center;
        float angle = acos(dot(normalize(relativePos), float3(0, 1, 0)));

		float value = calculateIslandSize(angle) * islands[i].size - length(relativePos);

		maxIslandValue = max(value, maxIslandValue);
	}
	return maxIslandValue;
}

[numthreads(8,8,8)]
void World (uint3 id : SV_DispatchThreadID)
{
	float3 pos = posFromID(id);

	float backgroundFieldValue = addNoise(pos, noiseParameters[0]);
	float islandFieldValue = islandValue(pos);

    Voxels[indexFromID(id)] = islandFieldValue - backgroundFieldValue;
}
